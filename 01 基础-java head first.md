java中int和boolean的是不可以相容的，判读中需要注意        
System.out.print  不换行       
System.out.println  换行       
java数据类型分为主数据类型和非主数据类型，主数据类型是传值，非主数据类型是传引用     
java中可以把小类型的数据放到大类型中，但是不可以把大类型的数据放到小类型中，因为可能导致数据溢出，同理也不可以直接将33.5隐式赋值给int型，需要显式类型转换    
java有两种数据类型：主数据类型和对象引用   
java中也存在封装机制，private public    
java中实例变量存在默认值，主数据类型默认为0，引用类型默认为null    
java中局部变量没有默认值，必须要初始化之后才能使用   
java中对于主数据类型，使用==是判断数据值是否相等，对于引用类型是判断引用是否指向同一个对象，equals用于比较是否在意义上相等      
string转int 使用integer.parseInt("3")    
arraylist  ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似 <int> 不能写，但是存储基本数据类型对应的包装类型是可以的。    
https://www.cnblogs.com/libinhong/p/10988945.html      

子类继承基类后，拥有私有变量的所有权，没有私有变量的使用权。         
default权限为包权限，只有在同一个包中才可以访问default修饰的东西         
https://blog.csdn.net/wanghao_0206/article/details/52710094       
抽象类不能被初始化，使用关键字abstract来设置抽象类     
抽象的方法只能存在于抽象类中，抽象的方法必须要被覆盖过才能使用，这就是多态       
任何从ArrayList<Object>取出的东西都会被当作Object类型的引用而不管它原来是什么   
java中不允许多重继承，c++中可以实现多重继承，java使用接口实现多重继承，即interface，需要注意的是一个类可以有多个接口  
java中使用super关键字在子类中执行父类方法   
java中堆栈的概念，栈是方法调用和局部变量，堆是对象    
实例变量存在于对象中，局部变量存在于栈上   
java中方法会被堆在一起，后被调用的方法会被放在栈顶，执行完之后再执行下面的方法    
jvav中局部变量中基础数据类型的引用和值都存储在栈中，对象引用存在栈中，对象存在堆中    
如果父类的构造函数是有参数的，则要在子类的构造函数中使用super调用父类的构造函数    
java中构造函数不能同时调用super和this,如果需要实现复杂的构造函数，可以使用this实现重载，方便代码的维护    
局部变量只存活在声明该变量的方法中，实例变量的寿命与对象相同，如果对象还活着，则实例变量也会是活的  
当最后一个引用消失时，对象就会变成可回收的，有3种方法可以释放对象的引用，1.引用永久离开它的范围 2.唯一引用被赋值到其他的对象上 3.直接将引用赋值为null  
java中静态方法与非静态方法，对于静态方法，不需要实例就可以直接调用，静态的方法不能调用非静态的变量或者函数，静态变量的值只有一份，是共享的！！静态的final变量是常量！！！    
final的变量代表不能改变值,final的方法代表不能覆盖该方法,final的类代表不能继承该类       
如果想要以对象的方法来处理primitive主数据类型时，就把它包装起来   
java使用try catch来处理异常，当try中遇到异常时直接跳转执行catch，不会将try中的语句全部执行   
使用try catch finally 来处理异常，其中finally的部分是必须要执行的部分，如果try和catch中有return,则先执行finally再return  
一个方法可以抛出多个异常，需要多个catch语句分别处理这多个异常，异常也可以多态，需要注意到catch的顺序，从小到大！！！使用catch时，java虚拟机只会从上往下开始找到第一个合适的异常处理块，如果上面的catch范围比下面的大，则下面的catch块根本不会被用到      
如果不想处理异常可以duck掉异常，但是异常并不会消失，它会被传给它的调用者去处理，一层一层往上踢皮球   
